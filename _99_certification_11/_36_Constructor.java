package _99_certification_11;

import java.io.IOException;

/*
Constructors:
--> The main objective of constructor is to perform initialization of object.
 	
 	Student s = new Student("Durga", 101);

-----------

constructor===> To perform initialization of an object.
instance block===> Other than initialization activity, if we want to perform any
					activity for every object creation. 

Q.
class Test{
	{
		System.out.println("Instance block");
	}
	Test(){
		System.out.println("no-arg constructor");
	}
	public static void main(String[] args) {
		Test t = new Test();
		Test t1 = new Test();
		Test t2 = new Test();
	}
}

o/p:
Instance block
no-arg constructor
Instance block
no-arg constructor
Instance block
no-arg constructor
---

Q.
class Test{
	static int count=0;
	{
		count++;
	}
	Test(){}
	Test(int i){}
	Test(double d){}
	public static void main(String[] args) {
		Test t = new Test();
		Test t1 = new Test(10);
		Test t2 = new Test(10.5);
		System.out.println("The number of objects created: "+count);
	}
}
answer: The number of objects created: 3
====================

instance block vs static block:
--> At the time of class loading if we want to perform any activity automatically, then
we have to define that activity inside static block.

class Test{
	static{
		System.out.println("static block");
	}
	{
		System.out.println("instance block");
	}
	Test(){
		System.out.println("no-arg constructor");
	}
	public static void main(String[] args) {
		System.out.println("main method");
		Test t1 = new Test();
		Test t2 = new Test();
	}
}
o/p:
static block
main method
instance block
no-arg constructor
instance block
no-arg constructor
============================

Rules for writing constructors:
1. the name of constructor should be same as class name.
2. return type concept not applicable for constructor including void type.
3. the only applicable modifiers for constructors are:
	public
	private
	protected
	<default>
Q.
class Test{
	void Test(){
		System.out.println("Hello");
	}
	public static void main(String[] args) {
		Test t1 = new Test();
	}
}
what is result?
A) Hello will be printed to the console.
B) Compilation fails
C) An exception is thrown at runtime.
D) Nothing will be printed to the console.
answer: D, void Test(){} will be treated as a method but not constructor.
---

Q.
class Test{
	void Test(){
		System.out.println("Hello");
	}
	public static void main(String[] args) {
		Test t1 = new Test();
		t1.Test();//Line-1
	}
}
what is result?
A) Hello will be printed to the console.
B) Compilation fails
C) An exception is thrown at runtime.
D) Nothing will be printed to the console.

answer: A, due to Line-1
It is legal to have a method whose name is exactly same as class name.
---

Q.
class Test{
	synchronized Test(){//CE:Illegal modifier for the constructor in type Test;
					   //only public, protected & private are permitted
		System.out.println("Hello");
	}
	public static void main(String[] args) {
		Test t1 = new Test();
	}
}
==================

default constructor:

Q.
s1: The compiler will always generates default constructor in every class.
s2: The compiler will generates default constructor if and only if our class
	does not contain atleast one constructor.

answer: only s2
explanation:
class Test{
	In this case compiler will generate default constructor.
}
class Test{
	In this case compiler won't generate default constructor.
	Test(int i){
	}
}
---

--> Every class in java contains constructor. It can be either default constructor
generated by compiler or customized constructor written explicitly by programmer
but not both simultaneously.

prototype of default constructor:
1. Default constructor is always no-arg constructor.
2. The access modifier of the default constructor is always same as class modifier.
3. It contains only one line
	super(); It is no-argument class to parent class constructor.
	
------------

Q. In which of the following cases, compiler will generate default constructor?
A)
class Test{

}
B)
public class Test{

}
C)
class Test(){
	void Test(){
	}
}
D)
class Test{
	Test(int i){
	}
}
E) All of these.

answer: A,B,C
1.
class Test{
	Test(){
		super();
	}
}

2.
public class Test{
	public Test(){
		super();
	}
}

3.
public class Test{
	void Test(){
		
	}
	public Test(){
		super();
	}
}
---------------


-->The first line inside every constructor should be super() or this(). If
we are not writing anything compiler will always place super(). 
 
Q.
class Test{
	Test(){
		System.out.println("constructor");
		super();
	}
}

CE: call to super() must be first statement in constructor.
---

Q.
class Test{
	Test(){
		super();
		System.out.println("constructor");
	}
}
valid.
---

--> we can write super() or this() only in the first line of the constructor. If we
are writing anywhere else we will get compile time error. Hence we cannot use
super() and this() both simultaneously.

Q.
class Test{
	Test(){
		super();//Line-1
		this();//Line-2
	}
}

CE: at Line-2 as this() and super() cannot be first statement simultaneously.
---

Q.
class Test{
	public void m1(){
		super();
		System.out.println("Method");
	}
}

CE, super() or this() is allowed only in constructors, (at first statement only)
=====================

super(), this()   vs  super,this

super(), this()=========> Constructor calls
super,this========> keywords to refer parent class and current class instance member.


super(), this()=========> only inside constructor in the first line only
super,this==============> Anywhere, any number of times except static area

class Test{
	public static void main(String[] args) {
		System.out.println(super.hashCode());//CE:Cannot use super in a static context
	}
}

---
===> overloaded constructors:
Q.
class Test{
	Test(double d){
		this(10);
		System.out.println("double-arg");
	}
	Test(int d){
		this();
		System.out.println("int-arg");
	}
	Test(){
		System.out.println("no-arg");
	}
	public static void main(String[] args) {
		Test t1= new Test(10);
	}
}
o/p:
no-arg
int-arg
----

Q.
class Test{
	Test(double d){
		this(10);
		System.out.println("double-arg");
	}
	Test(int d){
		this();
		System.out.println("int-arg");
	}
	Test(){
		System.out.println("no-arg");
	}
	public static void main(String[] args) {
		Test t1= new Test(10.5);
	}
}
o/p:
no-arg
int-arg
double-arg
========================

--> overloading is applicable for constructors
--> Inheritance is not applicable for constructors
--> overriding is not applicable for constructors

Q.
class P{
	public void m1() {}// method
	P(){}//no-arg constructor
}
class C extends P{
	public void m2() {}//method
	C(int i){}// int-arg constructor
}
class Test{
	public static void main(String[] args) {
		C c = new C(10);//Line-1
		C c1 = new C();//Line-2
		c.m1();//Line-3
		c.m2();//Line-4
	}
}
Which line causes compile time error?
answer: Line-2
----

Q.
class Test{
	public static void m1() {
		m2();
	}
	public static void m2() {
		m1();
	}
	public static void main(String[] args) {
		System.out.println("hello");
	}
}
o/p:
hello
---

Q.
class Test{
	public static void m1() {
		m2();
	}
	public static void m2() {
		m1();
	}
	public static void main(String[] args) {
		m1();
		System.out.println("hello");
	}
}
RE, recursive method call is always a runtime exception saying StackOverflowError.
=============

--> If there is any chance of recursive constructor invocation, then we will get
compile time error.

Q.
class Test{
	Test(){
		this(10);//CE:Recursive constructor invocation Test(int)
	}
	Test(int i){
		this();//CE:Recursive constructor invocation Test()
	}
	public static void main(String[] args) {
		System.out.println("hello");
	}
}
CE: recursive constructor invocation
---

Q.
class Test{
	Test(){
		Test t = new Test();
	}
	public static void main(String[] args) {
		System.out.println("hello");
	}
}
o/p:
hello
----

Q.
class Test{
	Test(){
		Test t = new Test();
	}
	public static void main(String[] args) {
		Test t = new Test();
		System.out.println("hello");
	}
}
RE:java.lang.StackOverflowError
-------

coding snippet-1:---------> valid
class P{

}
class C extends P{

}
==
coding snippet-2:---------> valid
class P{

}
class C extends P{
	C(int i){
	}
}
==
coding snippet-3:---------> invalid
class P{
	P(int i){
	}
}
class C extends P{
	
}
==
coding snippet-4:---------> valid
class P{
	P(int i){
	}
}
class C extends P{
	C(){
		super(10);
	}
}

--> It is always recommended to write no-arg constructor if we writing any argument
constructor.
--------

Q.
class P{
	P() throws IOException{
		
	}
}
class C extends P{
	
}
CE:Default constructor cannot handle exception type IOException thrown by 
implicit super constructor. Must define an explicit constructor
---

Q.
class P{
	P() throws IOException{
		
	}
}
class C extends P{
	C(){
		try {
			super();
		}catch(IOException e) {}
	}
}
CE: as super should be the 1st statement in constructor.
---

Q.
class P{
	P() throws IOException{
		
	}
}
class C extends P{
	C() throws IOException{
	}
}
valid
---

Q.
class P{
	P() throws IOException{
		
	}
}
class C extends P{
	C() throws Exception{
	}
}
valid

--> If parent class constructor throws any checked exception, then compulsory child class
constructor should throw the same checked exception or its parent.
 */
public class _36_Constructor {public static void main(String[] args) {}}